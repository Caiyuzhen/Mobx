{"ast":null,"code":"//Mobx 计算属性（基于现有的数据，经过一定的计算，得到一个新的数据）\n//How?\n//1.导入 makeAutoObservable 方法\n//2.定义一个原始数据\n//3.定义计算属性的函数\n//4.把数据定义成响应式的处理形态\n//5.实例化并导出实例，给 react 使用\nimport { makeAutoObservable } from 'mobx';\n\nclass CounterAttr {\n  constructor() {\n    this.List = [1, 2, 3, 4, 5, 6];\n  }\n\n  //2.定义计算属性的函数\n  filterList() {\n    return this.List.filter(item => item > 2); //拿到是 item > 2 的一个新数组\n  }\n\n}\n\nconst counterAttr = new CounterAttr();\nexport { counterAttr };","map":{"version":3,"names":["makeAutoObservable","CounterAttr","List","filterList","filter","item","counterAttr"],"sources":["/Users/zen/Desktop/Mobx/src/store/counterAttr.js"],"sourcesContent":["//Mobx 计算属性（基于现有的数据，经过一定的计算，得到一个新的数据）\n  //How?\n    //1.导入 makeAutoObservable 方法\n    //2.定义一个原始数据\n    //3.定义计算属性的函数\n    //4.把数据定义成响应式的处理形态\n    //5.实例化并导出实例，给 react 使用\n\n\nimport { makeAutoObservable } from 'mobx'\n\nclass CounterAttr {\n  //1.定义一个原始数据\n  List = [1,2,3,4,5,6]\n\n  //2.定义计算属性的函数\n  filterList(){\n    return this.List.filter(item => item > 2) //拿到是 item > 2 的一个新数组\n  }\n}\n\nconst counterAttr = new CounterAttr()\nexport {counterAttr}\n\n"],"mappings":"AAAA;AACE;AACE;AACA;AACA;AACA;AACA;AAGJ,SAASA,kBAAT,QAAmC,MAAnC;;AAEA,MAAMC,WAAN,CAAkB;EAAA;IAAA,KAEhBC,IAFgB,GAET,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,EAAS,CAAT,EAAW,CAAX,CAFS;EAAA;;EAIhB;EACAC,UAAU,GAAE;IACV,OAAO,KAAKD,IAAL,CAAUE,MAAV,CAAiBC,IAAI,IAAIA,IAAI,GAAG,CAAhC,CAAP,CADU,CACgC;EAC3C;;AAPe;;AAUlB,MAAMC,WAAW,GAAG,IAAIL,WAAJ,EAApB;AACA,SAAQK,WAAR"},"metadata":{},"sourceType":"module"}